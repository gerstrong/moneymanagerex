/*******************************************************
Copyright: (c) 2013-2026 Guan Lisheng (guanlisheng@gmail.com)
Copyright: (c) 2017-2018 Stefano Giorgio (stef145g)
Copyright: (c) 2022      Mark Whalley (mark@ipx.co.uk)
Copyright: (c) 2026      George Ef (george.a.ef@gmail.com)

 The code in this file was previously generated by [sqlite2cpp.py]
 ********************************************************/

#pragma once

#include "_TableBase.h"
#include "util/mmCache.h"

template<typename TableType, typename DataType>
struct TableFactory : public TableType
{
    static_assert(std::is_base_of<TableBase, TableType>::value,
        "TableType must derive from TableBase"
    );

public:
    using Table  = TableType;
    using Row    = typename Table::Row;
    using Col    = typename Row::Col;
    using COL_ID = typename Col::COL_ID;
    using Data   = DataType;

    // A container to hold a list of Data records for the table
    struct DataA : public std::vector<Data>
    {
        const wxString to_json() const;
    };

protected:
    mmCache<int64, Data> m_cache;

public:
    TableFactory<TableType, DataType>() : m_cache(mmCache<int64, Data>()) {};
    ~TableFactory<TableType, DataType>() { m_cache.reset(); };

    // methods starting with 'find_' bypass the cache; other methods use the cache.
    auto unsafe_get_data_n(const int64 id) -> Data*;
    auto get_data_n(const int64 id) -> const Data*;
    auto get_data_n(wxLongLong_t id) -> const Data* { return get_data_n(int64(id)); }
    auto add_data(Data& data) -> const Data*;
    bool add_data_a(DataA& data);
    auto unsafe_update_data(Data* data) -> Data*;
    auto update_data(Data& data) -> const Data*;
    auto unsafe_save_data(Data* data) -> const Data*;
    auto save_data(Data& data) -> const Data*;
    bool save_data_a(DataA& data);
    bool remove_data(const int64 id);
    auto find_all(const COL_ID = Col::PRIMARY_ID, const bool asc = true) -> const DataA;
    void preload_cache(int max_size = 1000);
    void reset_cache() { m_cache.reset(); }
    bool cache_empty() const { return m_cache.get_stat().max_size == 0; }
    auto stat_json() const -> const wxString;
    void debug_stat() const;

    virtual bool remove_depen(int64 id) { return remove_data(id); }

    template<typename... Args>
    auto unsafe_search_cache_n(const Args& ... args) -> Data*
    {
        for (auto& [_, r] : m_cache.get_map()) {
            if (r->id() > 0 && r->to_row().match(args...)) {
                return r;
            }
        }
        return nullptr;
    }

    template<typename... Args>
    auto search_cache_n(const Args& ... args) -> const Data*
    {
        return unsafe_search_cache_n(args...);
    }

    /*
     * Return the result of a SELECT query as an array of Data records.
     * The WHERE conditions are specified by one or more Specialised Parameters
     * of the form: *Col::ColumnName(op, value) or *Col::ColumnName(value).
     * The conditions are combined with AND or OR, if op_and is true or false, resp.
     * Example:
     *   true, AssetCol::ASSETID(2), AssetCol::ASSETTYPE(AssetModel::TYPE_ID_JEWELLERY)
     *   produces the SQL statement condition: ASSETID = 2 AND ASSETTYPE = "Jewellery"
     * Return an empty array if no records are found.
     */
    template<typename... Args>
    auto find_where(bool op_and, const Args&... args) -> const DataA
    {
        DataA result;
        try {
            wxString query = this->m_select_query + " WHERE ";
            write_condition(query, op_and, args...);
            wxSQLite3Statement stmt = this->m_db->PrepareStatement(query);
            bind_at(stmt, 1, args...);
            wxSQLite3ResultSet q = stmt.ExecuteQuery();

            while (q.NextRow()) {
                Data r(q);
                result.push_back(std::move(r));
            }

            q.Finalize();
        }
        catch(const wxSQLite3Exception &e) {
            wxLogError("%s: Exception %s", this->m_table_name, e.GetMessage().utf8_str());
        }

        return result;
    }

    // Shorter name for conditions combined with AND (most common usage).
    template<typename... Args>
    auto find(const Args&... args) -> const DataA { return find_where(true, args...); }

    // Longer name for conditions combined with OR (less common usage).
    template<typename... Args>
    auto find_or(const Args&... args) -> const DataA { return find_where(false, args...); }

    template<typename Arg1>
    void write_condition(wxString& out, bool /*op_and*/, const Arg1& arg1)
    {
        out += Arg1::col_name();
        switch (arg1.m_operator) {
            case OP_GT: out += " > ? ";  break;
            case OP_GE: out += " >= ? "; break;
            case OP_LT: out += " < ? ";  break;
            case OP_LE: out += " <= ? "; break;
            case OP_NE: out += " != ? "; break;
            default:    out += " = ? ";  break;
        }
    }

    template<typename Arg1, typename... Args>
    void write_condition(wxString& out, bool op_and, const Arg1& arg1, const Args&... args)
    {
        out += Arg1::col_name();
        switch (arg1.m_operator) {
        case OP_GT: out += " > ? ";  break;
        case OP_GE: out += " >= ? "; break;
        case OP_LT: out += " < ? ";  break;
        case OP_LE: out += " <= ? "; break;
        case OP_NE: out += " != ? "; break;
        default:    out += " = ? ";  break;
        }
        out += op_and? " AND " : " OR ";
        write_condition(out, op_and, args...);
    }

    template<typename Arg1>
    void bind_at(wxSQLite3Statement& stmt, int index, const Arg1& arg1)
    {
        stmt.Bind(index, arg1.m_value);
    }

    template<typename Arg1, typename... Args>
    void bind_at(wxSQLite3Statement& stmt, int index, const Arg1& arg1, const Args&... args)
    {
        stmt.Bind(index, arg1.m_value);
        bind_at(stmt, index+1, args...);
    }
};
