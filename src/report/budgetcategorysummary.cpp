/*************************************************************************
 Copyright (C) 2012 Stefano Giorgio
 Copyright (C) 2017 James Higley
 Copyright (C) 2021-2022 Mark Whalley (mark@ipx.co.uk)

 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *************************************************************************/

 /*************************************************************************
  Renamed after extensive modifications to original file reportbudgetsetup.cpp
 **************************************************************************/

#include "base/defs.h"
#include "mmex.h"
#include "util/mmDateRange.h"
#include "htmlbuilder.h"

#include "model/BudgetPeriodModel.h"
#include "model/BudgetModel.h"
#include "model/CategoryModel.h"
#include "mmframe.h"
#include "budgetcategorysummary.h"

mmReportBudgetCategorySummary::mmReportBudgetCategorySummary()
{
    m_chart_selection = 1;
    setReportParameters(REPORT_ID::BudgetCategorySummary);
}

mmReportBudgetCategorySummary::~mmReportBudgetCategorySummary()
{}

wxString mmReportBudgetCategorySummary::getHTMLText()
{
    // Grab the data 
    int startDay;
    wxDate::Month startMonth;
    if (PrefModel::instance().getBudgetFinancialYears())
    {
        GetFinancialYearValues(startDay, startMonth);
    } else
    {
        startDay = 1;
        startMonth = wxDateTime::Jan;
    }

    long tmp;
    int startYear = wxDateTime::Today().GetYear();

    wxString value = BudgetPeriodModel::instance().Get(m_date_selection);
    wxString budget_month, budget_year = value;

    wxRegEx pattern("^([0-9]{4})(-([0-9]{2}))?$");
    if (pattern.Matches(value))
    {
        budget_year = pattern.GetMatch(value, 1);
        budget_month = pattern.GetMatch(value, 3);
    }

    if (budget_year.ToLong(&tmp))
        startYear = static_cast<int>(tmp); // 0 <= tmp <= 9999

    budget_year = wxString::Format("%d", startYear);

    long budgetMonth = 0;
    if (budget_month.ToLong(&budgetMonth))
    {
        if (startMonth != wxDateTime::Jan)
            startMonth = wxDateTime(1, startMonth, startYear).Add(wxDateSpan::Months(--budgetMonth)).GetMonth();
        else
            startMonth = static_cast<wxDateTime::Month>(--budgetMonth);
    }

    wxDateTime yearBegin(startDay, startMonth, startYear);
    wxDateTime yearEnd = yearBegin;

    bool monthlyBudget = (!budget_month.empty());
    if (monthlyBudget) {
        yearEnd.Add(wxDateSpan::Month()).Subtract(wxDateSpan::Day());
        budget_year = wxString::Format("%i-%ld", startYear, budgetMonth);
    }
    else
        yearEnd.Add(wxDateSpan::Year()).Subtract(wxDateSpan::Day());

    // Readjust dates by the Budget Offset Option
    PrefModel::instance().addBudgetDateOffset(yearBegin);
    PrefModel::instance().addBudgetDateOffset(yearEnd);
    mmSpecifiedRange date_range(yearBegin, yearEnd);

    bool evaluateTransfer = false;
    if (PrefModel::instance().getBudgetIncludeTransfers())
    {
        evaluateTransfer = true;
    }
    //Get statistics
    std::map<int64, BudgetModel::PERIOD_ID> budgetPeriod;
    std::map<int64, double> budgetAmt;
    std::map<int64, wxString> budgetNotes;
    BudgetModel::instance().getBudgetEntry(m_date_selection, budgetPeriod, budgetAmt, budgetNotes);

    std::map<int64, std::map<int, double> > categoryStats;
    CategoryModel::instance().getCategoryStats(categoryStats
        , static_cast<wxSharedPtr<wxArrayString>>(nullptr)
        , &date_range, PrefModel::instance().getIgnoreFutureTransactions()
        , false, (evaluateTransfer ? &budgetAmt : nullptr));

    std::map<int64, std::map<int, double> > budgetStats;
    BudgetModel::instance().getBudgetStats(budgetStats, &date_range, monthlyBudget);


    // Build the report
    mmHTMLBuilder hb;
    hb.init();
    wxString headingStr = AdjustYearValues(startDay, startMonth, startYear, budget_year);
    bool amply = PrefModel::instance().getBudgetSummaryWithoutCategories();
    const wxString headerStartupMsg = amply
        ? _t("Budget Categories for %s") : _t("Budget Category Summary for %s");

    headingStr = wxString::Format(headerStartupMsg
        , headingStr + "<br>" + _t("(Estimated vs. Actual)"));
    hb.addReportHeader(headingStr, 1, PrefModel::instance().getIgnoreFutureTransactions());
    hb.displayDateHeading(yearBegin, yearEnd);
    // Prime the filter
    m_filter.clear();
    m_filter.setDateRange(yearBegin, yearEnd);

    CategoryModel::DataA categs = CategoryModel::instance().find(CategoryCol::PARENTID(-1));
    std::stable_sort(categs.begin(), categs.end(), CategoryData::SorterByCATEGNAME());

    // Chart
    if (getChartSelection() == 0)
    {
        GraphData gd;
        GraphSeries gsActual, gsEstimated;

        for (const auto& category : categs)
        {
            wxString categName = category.m_name;
            gsEstimated.name = _t("Estimated");
            gsActual.name = _t("Actual");

            gd.title = categName;
            gd.labels.push_back(category.m_name);
            gsActual.values.push_back(categoryStats[category.m_id][0]);
            gsEstimated.values.push_back(budgetStats[category.m_id][budgetMonth]);
            for(const auto& subcat : CategoryModel::sub_tree(category)){
                gd.labels.push_back(CategoryModel::full_name(subcat.m_id));
                gsActual.values.push_back(categoryStats[subcat.m_id][0]);
                gsEstimated.values.push_back(budgetStats[subcat.m_id][budgetMonth]);
            }

            if (gd.labels.size() > 1) // Bar/Line are best with at least 2 items 
            {
                gd.type = GraphData::BARLINE;
                gsEstimated.type = "column";
                gsActual.type = "line";
            }
            else
            {
                gd.type = GraphData::BAR;
            }
            gd.series.push_back(gsActual);
            gd.series.push_back(gsEstimated);
            hb.addChart(gd);

            // Now clear for next chart
            gsActual.values.clear();
            gsEstimated.values.clear();
            gd.labels.clear();
            gd.series.clear();
        }
    }
    hb.addDivContainer("shadow");
    {
        double estIncome = 0.0, estExpenses = 0.0, actIncome = 0.0, actExpenses = 0.0;
        hb.startTable();
        {
            hb.startThead();
            {
                hb.startTableRow();
                {
                    hb.addTableHeaderCell(_t("Category"));
                    hb.addTableHeaderCell(_t("Estimated"), "text-right");
                    hb.addTableHeaderCell(_t("Actual"), "text-right");
                }
                hb.endTableRow();
            }
            hb.endThead();
            hb.startTbody();
            {
                std::map<int64, double> catTotalsEstimated, catTotalsActual;
                std::map<int64, std::pair<int, wxString>> categLevel;
                for (const auto& category : categs)
                {
                    categLevel[category.m_id].first = 0;
                    double estimated = budgetStats[category.m_id][budgetMonth];

                    if (estimated < 0)
                        estExpenses += estimated;
                    else
                        estIncome += estimated;

                    double actual = categoryStats[category.m_id][0];
                    if (actual < 0)
                        actExpenses += actual;
                    else
                        actIncome += actual;

                    catTotalsActual[category.m_id] += actual;
                    catTotalsEstimated[category.m_id] += estimated;

                    if (amply)
                    {
                        hb.startTableRow();
                        {
                            hb.addTableCellLink(wxString::Format("viewtrans:%lld"
                                , category.m_id)
                                , category.m_name);
                            hb.addMoneyCell(estimated);
                            hb.addMoneyCell(actual);
                        }
                        hb.endTableRow();
                    }
                    
                    std::vector<int> totals_stack;
                    CategoryModel::DataA subcats = CategoryModel::sub_tree(category);
                    for (int i = 0; i < static_cast<int>(subcats.size()); i++) {
                        categLevel[subcats[i].m_id].first = 1;
                        estimated = budgetStats[subcats[i].m_id][budgetMonth];

                        if (estimated < 0)
                            estExpenses += estimated;
                        else
                            estIncome += estimated;

                        actual = categoryStats[subcats[i].m_id][0];
                        if (actual < 0)
                            actExpenses += actual;
                        else
                            actIncome += actual;

                        //save totals for this subcategory
                        catTotalsEstimated[subcats[i].m_id] = estimated;
                        catTotalsActual[subcats[i].m_id] = actual;

                        //update totals of the category
                        catTotalsEstimated[category.m_id] += estimated;
                        catTotalsActual[category.m_id] += actual;

                        //walk up the hierarchy and update all the parent totals as well
                        int64 nextParent = subcats[i].m_parent_id;
                        for (int j = i; j > 0; j--) {
                            if (subcats[j - 1].m_id == nextParent) {
                                categLevel[subcats[i].m_id].first++;
                                catTotalsEstimated[subcats[j - 1].m_id] += estimated;
                                catTotalsActual[subcats[j - 1].m_id] += actual;
                                nextParent = subcats[j - 1].m_parent_id;
                                if (nextParent == category.m_id)
                                    break;
                            }
                        }
                        categLevel[subcats[i].m_id].second = "";
                        for (int j = categLevel[subcats[i].m_id].first; j > 0; j--) {
                            categLevel[subcats[i].m_id].second.Prepend("&nbsp;&nbsp;&nbsp;&nbsp;");
                        }
                        if (amply) {
                            hb.startTableRow();
                            {
                                hb.addTableCell(wxString::Format(categLevel[subcats[i].m_id].second + "<a href=\"viewtrans:%lld\" target=\"_blank\">%s</a>"
                                    , subcats[i].m_id
                                    , subcats[i].m_name));
                                hb.addMoneyCell(estimated);
                                hb.addMoneyCell(actual);
                            }
                            hb.endTableRow();
                            
                            if (i < static_cast<int>(subcats.size()) - 1) { //not the last subcategory
                                if (subcats[i].m_id == subcats[i + 1].m_parent_id) totals_stack.push_back(i); //if next subcategory is our child, queue the total for after the children
                                else if (subcats[i].m_parent_id != subcats[i + 1].m_parent_id) { // last sibling -- we've exhausted this branch, so display all the totals we held on to
                                    while (!totals_stack.empty() && subcats[totals_stack.back()].m_id != subcats[i + 1].m_parent_id) {
                                        hb.startAltTableRow();
                                        {
                                            int index = totals_stack.back();
                                            hb.addTableCell(wxString::Format(categLevel[subcats[index].m_id].second + "<a href=\"viewtrans:%lld:-2\" target=\"_blank\">%s</a>"
                                                , subcats[index].m_id
                                                , subcats[index].m_name));
                                            hb.addMoneyCell(catTotalsEstimated[subcats[index].m_id]);
                                            hb.addMoneyCell(catTotalsActual[subcats[index].m_id]);
                                        }
                                        hb.endTableRow();
                                        totals_stack.pop_back();
                                    }
                                }
                            }
                            // the very last subcategory, so show the rest of the queued totals
                            else {
                                while (!totals_stack.empty()) {
                                    hb.startAltTableRow();
                                    {
                                        int index = totals_stack.back();
                                        hb.addTableCell(wxString::Format(categLevel[subcats[index].m_id].second + "<a href=\"viewtrans:%lld:-2\" target=\"_blank\">%s</a>"
                                            , subcats[index].m_id
                                            , subcats[index].m_name));
                                        hb.addMoneyCell(catTotalsEstimated[subcats[index].m_id]);
                                        hb.addMoneyCell(catTotalsActual[subcats[index].m_id]);
                                    }
                                    hb.endTableRow();
                                    totals_stack.pop_back();
                                }
                            }
                        }
                    }
                    amply ? hb.startAltTableRow() : hb.startTableRow();
                    {
                        hb.addTableCellLink(wxString::Format("viewtrans:%lld:-2"
                            , category.m_id)
                            , category.m_name);
                        hb.addMoneyCell(catTotalsEstimated[category.m_id]);
                        hb.addMoneyCell(catTotalsActual[category.m_id]);
                    }
                    hb.endTableRow();
                }
            }
            hb.endTbody();
        }
        hb.endTable();
        hb.startTable();
        {
            double difIncome = actIncome - estIncome;
            double difExpense = actExpenses - estExpenses;

            //Summary of Estimated Vs Actual totals
            hb.startTbody();
            {
                hb.startTotalTableRow();
                {
                    hb.addTableCell(_t("Estimated Income:"));
                    hb.addMoneyCell(estIncome);
                    hb.addTableCell(_t("Actual Income:"));
                    hb.addMoneyCell(actIncome);
                    hb.addTableCell(_t("Difference Income:"));
                    hb.addMoneyCell(difIncome);
                }
                hb.endTableRow();

                hb.startTotalTableRow();
                {
                    hb.addTableCell(_t("Estimated Expenses:"));
                    hb.addMoneyCell(estExpenses);
                    hb.addTableCell(_t("Actual Expenses:"));
                    hb.addMoneyCell(actExpenses);
                    hb.addTableCell(_t("Difference Expenses:"));
                    hb.addMoneyCell(difExpense);
                }
                hb.endTableRow();
            }
            hb.endTfoot();
        }
        hb.endTable();
    }
    hb.endDiv();

    hb.end();

    wxLogDebug("======= mmReportBudgetCategorySummary:getHTMLText =======");
    wxLogDebug("%s", hb.getHTMLText());

    return hb.getHTMLText();
}
